c======================================================================
c======================================================================
c     GENRAY-c version              CompX                       2012
c======================================================================
c======================================================================

Main feature:  Integration of ray trajectories in cartesian coordinates. 

The old version can be revoked by setting ixyz=0 
(with limited capabilities on magnetic field configuration).

The input values for a run are specified in file genray.in [MKSA units].
The output data is written into netCDF file genray.nc.
The data from this file can be plotted with the Python program 
genray_plot.py 
(or genray_plot_py_scipy_io.py  - it differs in netcdf interface).

makefiles: makefile_franklin_pgi  for the pgi compiler 
          (NERSC-franklin machine);
           makefile_gfortran64  for the gfortran compiler.
(remove "-lpgplot" if it gives problems; PGPLOT is not used by Genray-c)


--------------------------------------------------------------------------
How to specify model magnetic field and density profiles in genray.in :

Equilibrium magnetic field configuration:  model_b=0,1,2,4 (see below).

Density 3D-profile: model_rho_dens=0,1,2,3,4 (see below).


Specify in genray.in:

!--------------------------------------------------------------------------
! Yu.P. Added in 2011
! ixyz =0 - old r-phi coordinate system;  
!      =1 - new x,y,z cartesian system      (Default value now)
!--------------------------------------------------------------------------
! Yu.P. Most of models are added in 2011, unless specified otherwise.
! model_b=0 - read eqdsk file as specified above; 
! model_b=1
c        Magnetic field is set as  Bz=uniform, Br=0, Bphi~1/r
c        Skip reading eqdsk in this case.
!               Set components of b-field analytically as 
!               bz=bz0 (uniform), br=0, bphi=rbphi0/r
!               Specify values of bz0 and rbphi0 in /tokamak/ namelist
!
! model_b=2
c        Magnetic field is calculated from a set of magnetic coils
c        (current loops). This is suitable for a mirror machine.
c        Toroidal Bphi~1/r can be added, similar to model_b=1.
c        Skip reading eqdsk in this case.
!               Specify in namelist /tokamak/ :
!               radc(ncoils) - radii of coils (loops) [m].
!               zcoil(ncoils)- z-coordinates of coils' centers;
!                  the centers are on the z-axis,
!                  with loop's plane perpendicular to the z-axis.
!               curc(ncoils) - loop current in each coil [A], 
!                  positive curc is in positive phi-direction.
!
! model_b=3
!        Added in [04-2016]. A mirror-machine type magnetic field.
!        The model is based on analytical equations for Br and Bz 
!        components (in R,Z cylindrical coordinates). 
!        The advantage over model_b=2 is that model_b=3 produces 
!        field lines that have only one minimum-B point 
!        (at the equatorial plane Z=0). This is the type of equilibrium
!        that can be handled by CQL3D code. In CQL3D, this exact model 
!        is also present and named "mirror1" model (eqsource="mirror1").
!        The model is defined by 
!        Bz(R,Z)=  B00*J0(R/glb)*cosh(Z/glb)
!        Br(R,Z)= -B00*J1(R/glb)*sinh(Z/glb)
!        where B00 is the value of |B| at (Z=0,R=0),
!        glb is the scale length of magnetic field increase.
!        J0 and J1 are the Bessel functions of argument (R/glb).
!        In addition, the poloidal flux function is 
!        PSI= INTEGRAL[0_R]{Bz*R*dR)= B00*R*glb*J1(R/glb)*cosh(Z/glb)
!        It can be verified that for the model equations above,
!        div.B=0, which is in cylindrical coords (using d/dphi=0)
!        (1/R)d(R*Br)/dR + d(Bz)/dZ = 0.
!        Also it can be shown that curl(B) = dBr/dZ - dBz/dR = 0,
!        for the specified model equations.
!        Note that the mirror ratio is Bz(Zmax,R=0)/B00 =cosh(Zmax/glb).
!        To setup the model, specify in genray.in, namelist /tokamak/ :
!            zbox_mirror= [m] (default is 1.0 m):
!                  It defines the distance
!                  from one magnetic throat to the other.
!                  In the above description, zbox_mirror=2*Zmax,
!                  so effectively zbox_mirror defines the location of 
!                  magnetic throats at 
!                  Z= +zbox_mirror/2 and -zbox_mirror/2.
!            rbox_mirror= [m] (default is 1.0 m): 
!                  It defines the R radius at the equatorial plane
!                  which corresponds to rho=1 position.
!                  So effectively it defines the edge of plasma.
!                  However, when the model is setup in subroutine input,
!                  the value of rbox_mirror can be reset to a smaller value, 
!                  to avoid the 1st null of J0(R/glb) Bessel function,
!                  ( rbox_mirror= 0.95*R_b0, 
!                   where R_b0 is such that J0(R_b0/glb)=0 ).
!            rmirror= (default is 2.) 
!                  From value of rmirror, the value of glb is found
!                  as  glb_mirror= 0.5*zbox_mirror/acosh(rmirror)
!                  Note: zbox_mirror=2*Zmax.
!            b00_mirror= [T] (default is 1.0 T) 
!                  This is B00==B(R=0,Z=0) in mirror machine,
!                  see the model equations above.
!
! model_b=4
c        FRC-type magnetic field. Components are set as
c         b_x= 0.d0
c         b_y= 0.d0
c         b_z= bz0*tanh( akappa*[2*(r/rs_frc)**2  - 1.] )
c        where
c         rs_frc  - separatrix radius (specify in genray.in) [m]
c         bz0     - magnetic field at r=+INF, approximately at wall [T]
c         akappa  - such "Kappa" that  beta_frc*Kappa-tanh(Kappa)=0
c         beta_frc= 1.d0 - 0.5*(rs_frc/wall_rmax)**2
c        The value of akappa is found in subroutine input :
c        akappa= rtbis(func_kappa, 1.d-5, 10.d0, 1.d-14)
c        Last three arguments: initial guesses that bracket the root
c        and the accuracy for searching the root. Adjust if needed.
c        Also, the Toroidal Bphi~1/r can be added, similar to model_b=1.
c        Such FRC-magnetic field is associated with the density profile
c        (model_rho_dens=4)  (FRC-like plasma)
c        !-1-> Rigid Rotor profile:
c         dens_rr= dens0rr*( sech(akappa*rho) )**2
c        where rho=abs(2*(r/rs_frc)**2 -1.) 
c        ! With such definition, rho=0 at r=rs_frs/sqrt(2), 
c        ! and rho=1 at r=0 or r=rs_frc .
c        ! Note: At r=0 and r=rs_frc, dens_rr= dens0rr*[sech(akappa)]^2
c        !-2-> Uniform background density profile is also added:
c         dens_ub= dens0ub 
c        if (r .gt. rs_frc) then 
c           ! Linear drop in region  rs_frc < r < wall_rmax
c           dens_ub= dens0ub*(1.d0 -(r-rs_frc)/(wall_rmax-rs_frc))
c        endif
c        dense_xyz= dens_rr + dens_ub !electrons only, for now
!
! Other models for b will be added later.
!
! For all model_b .ne. 0 :
! Specify the dimensions of a straight cylind. chamber
! wall_rmin= inner radius of chamber
! wall_rmax= outer radius of chamber
! wall_zmin= bottom wall
! wall_zmax= top wall
!    These values will be used to set grids and to stop rays,
!    (rays are also stopped by hitting r_wall(1:n_wall), z_wall(1:n_wall), 
!     if specified).
!    wall_rmax, wall_rmin, wall_zmax, wall_zmin will be overwritten
!    by min/max of abs(r_wall()), z_wall() (if n_wall>0).
!
!--------------------------------------------------------------------------
! -----------------------------------------------------
! Yu.P. Added in 2011                    model_rho_dens
!
! model_rho_dens=0, the definition of rho for plasma profiles 
!     is based on psi - magnetic flux, as before.
c     YuP[Added in 2014] 
c     [modified in Jan-2016: now for each species]: 
c     Now, the density profile is set as den(rho)*gn(z),
c     where gn(z) is the dropoff function,
c     such that at |z|<zbegin_den_dropoff , 
c     the density profile is just den(rho) (with gn(z)==1),
c     but at |z|>zbegin_den_dropoff ,
c     the density drops exponentially over the 
c     effective length = zlength_den_dropoff .
c     By default, zlength_den_dropoff is set to 0.d0, 
c     which will set gn(z) to 1.0 everywhere.
c     This option is only available for model_rho_dens=0, for now.
!     Default values:
! zbegin_den_dropoff(i)=1.0d+10 ! Any large number - 
!                               ! means that |z| would never reach it
! zlength_den_dropoff(i)=0.d0   ! Zero => no drop-off is applied.
! Should be set for each species i=1:nbulk in genray.in
!
!.................
!.................
! model_rho_dens=1 or 2 or 3 or 4.   
!      Only works with idens=0.
!      The profile of density (also Temperature, Tpop, Vflow, Zeff)
!      is determined on analytically defined surfaces, 
!      different from magnetic flux surfaces.  
!      The models are adequate for a weakly-ionized FRC.
!.................
!.................
! model_rho_dens=1 
! Defines rho-coordinate on ellipsoid surfaces.
! See functions rho_dens_xyz(x,y,z) and dense_xyz(x,y,z,i) for details.
! rho is defined as:
!      rho2=   (( (x-elx0)*costt + (y-ely0)*sintt )/elax)**2
!             +((-(x-elx0)*sintt + (y-ely0)*costt )/elay)**2 
!             +((z-elz0)/elaz)**2  
!      rho_dens_xyz= sqrt(rho2)
! where
!      elthet=eltheta*pi/180 ! [rad] inclination of the ellipse in x-y
!      sintt= sin(elthet) !-> to one.i
!      costt= cos(elthet) !-> to one.i
! where elax, elay, elaz are the semi-axes of the ellipsoid 
! in cartesian coordinates, 
! and elx0, ely0, elz0 are the coordinates of its center.
! Axis z is in the same direction as the vertical coordinate
! in tokamaks; x and y are in r-phi plane.
! The profile of density is then set as (idens=0 option)
!   dens1(k,i)=(dense0(i)-denseb(i))*
!              (1-rhom(k)**rn1de(i))**rn2de(i) + denseb(i)
! Same definition of rho is applied to setting profiles of
! temp1, tpop1, vflow1, zeff1.
!.................
!.................
! model_rho_dens=2 
! The profile of density is set as the sum of three types:
! Rigid Rotor ("rr") profile, 
! Ellipsoidal Spindle ("es") profile,
! Uniform Background ("ub") profile.
! See functions rho_dens_xyz(x,y,z) and dense_xyz(x,y,z,i) for details.
! rho is defined similar to model_rho_dens=1:
!      rho2=   (( (x-elx0)*costt + (y-ely0)*sintt )/elax)**2
!             +((-(x-elx0)*sintt + (y-ely0)*costt )/elay)**2 
! (uniform in z, for now)
!      rho_dens_xyz= sqrt(rho2)
! where
!      elthet=eltheta*pi/180.d0 ! [rad] inclination of the ellipse in x-y
!      sintt= sin(elthet) !-> to one.i
!      costt= cos(elthet) !-> to one.i
! where elax, elay are the semi-axes of the ellipse 
! and   elx0, ely0 are the coordinates of its center.
!-1-> Rigid Rotor profile:
!       Rs0rr= max(elax,elay)
!       rrk=(Rm0rr/Rs0rr)**2  ! K in Eq.(38)
!       Rs=Rs0rr ! Assume no dependence in z, for now
!       dens_rr= dens0rr*( sech(rho2-rrk)/sech(rrk) )**2
!       ! Note: At rho=0 -> nrr= n0rr
!       ! Note: At rho=1 -> nrr= n0rr*[sech(1-K)/sech(K)]^2
!-2-> Ellipsoidal Spindle profile:
!       dens_es= dens0es* exp( -(Rs*rho-Rm0es)**2 / (2*rtau**2) )
!-3-> Uniform background density profile:
!       dens_ub= dens0ub 
!       r= sqrt(x*x+y*y)
!       if (r .gt. r_ub_edge) then 
!          ! Linear drop in region  r_ub_edge < r < wall_rmax
!          dens_ub= dens0ub*(1.d0 -(r-r_ub_edge)/(wall_rmax-r_ub_edge))
!       endif
!===> NEED TO SPECIFY:
! Peak densities for the three types of profiles:
! dens0rr= ! [m^-3] Peak density for Rigid Rotor profile
! dens0es= ! [m^-3] Peak density for Ellipsoidal Spindle profile
! dens0ub= ! [m^-3] Density for Uniform Background profile
!-1-> Input for the Rigid Rotor profile:
! Position of plasma center:
! elx0= ! [m]
! ely0= ! [m]
! Semi-axes of the ellipse:
! elax= ! [m] 
! elay= ! [m]
! eltheta= ! [degrees] inclination of the ellipse-profile in x-y plane
! (Note: Rs0rr (Separatrix radius at z=z0) is set to max(elax,elay) )
! Rm0rr= ! [m] Radius of peak power emission at z=z0, for Rigid Rotor
!-2-> Input for the Ellipsoidal Spindle profile:
! Rm0es= ! [m] Radius of peak power emission at z=z0, for Ell.Spindle
! rtau=  ! [m] Radial decay distance (==tau_R in Eq.(44))
!-3-> Input for the uniform background profile:
! r_ub_edge= ! [m] Radius for the uniform background density; 
             !     drops linearly to zero from r_ub_edge to wall_rmax
!.................
!.................
! model_rho_dens=3
! Read 2D density profile from file.
! Assumed: uniform (x,y)-grid,
! Density profile is a function of (x,y) only.
!===> NEED TO SPECIFY THE NAME OF INPUT FILE:
! dendsk="19846_0_25densf.dat"   (example)
! Check that the data in file is in these units: 10^19 [m^-3]
!.................
!.................
! model_rho_dens=4        (FRC-like plasma)      
!        Associated with the FRC-magnetic field profile (model_b=4)
!        See /tokamak/ namelist.
!        The density profile is the sum of  dens_rr + dens_ub :
!        !-1-> Rigid Rotor profile:
!         dens_rr= dens0rr*( sech(akappa*rho) )**2
!        where rho=abs(2*(r/rs_frc)**2 -1.) 
!        ! With such definition, rho=0 at r=rs_frs/sqrt(2), 
!        ! and rho=1 at r=0 or r=rs_frc .
!        ! Note: At r=0 and r=rs_frc, dens_rr= dens0rr*[sech(akappa)]^2
!        !-2-> Uniform background density profile is also added:
!         dens_ub= dens0ub    (for r<rs_frc)
!        with a linear drop in region  rs_frc < r < wall_rmax :
!         dens_ub= dens0ub*(1.d0 -(r-rs_frc)/(wall_rmax-rs_frc))
!===> NEED TO SPECIFY:
! Peak densities for the two parts :
! dens0rr= ! [m^-3] Peak density for Rigid Rotor profile
! dens0ub= ! [m^-3] Density for Uniform Background profile
!.................
! (Other models can be added later).   
!------------------------------------------------------


Launching Whistler waves:
Use cold plasma dispersion (id=2).

Specify the launching point, for example:
 ilaunch=1 ! all rays are launched from this point
 r0launch=  9.1d-2  ! [m] launching r for whistler
 z0launch=-38.1d-2  ! [m] launching z for whistler
 phi0launch=0.d0    ! [degrees]
 
Specify the range for Npar, for example:
 anmax(1)=1.6d0 !! launching Npar for whistler
 anmin(1)=1.4d0 !!
 nnkpar(1)=5    !! how many different npar 

The necessary condition for Whistler launch is 
(omega_pe/omega)^2 > 1  (which we write as xe>1)
and
omega_ce/omega > 1  (which we write as ye>1).
Also, the value of Npar^2 should be about 
Npar^2= 1- xe/(1-ye)  
or somewhat higher.

If these values are not known, 
specify any Npar and 
look for this print-out from dinit_1ray_xyz() subroutine:

      write(*,*)'-------------------------------------------------'
      write(*,*)'xe==(omega_pe/omega)^2 = ',x_e
      write(*,*)'ye==(omega_ce/omega)   = ',y_e
      write(*,*)'For Whistler need: Npar^2= 1- xe/(1-ye)=',1-x_e/(1-y_e)
      write(*,*)'For Whistler launch, make sure xe>1, ye>1, '
      write(*,*)'and Npar = sqrt[1- xe/(1-ye)] or a little larger.'
      write(*,*)'Npar^2 from input data  ==', cnpar2
      write(*,*)'-------------------------------------------------'

It will show the values of xe and ye, and the value
of Npar^2= 1- xe/(1-ye).  Then, specify anmin and anmax 
above Npar = sqrt[1- xe/(1-ye)].



=====================================================================
i_ox=2 option:
Launching O-mode, which is then converted to X-mode, 
which is then converted to EBW.

In genray.in, in /wave/ namelist section, specify 
 jwave=+1 ! EC wave
 ioxm=+1  ! The code will be looking for Nperp of O-mode at launching point
 ibw=0    ! Not a direct EBW launch (but rather through O-X-EBW)
 istart=1 ! Use /ec_cone/ namelist section for starting conditions
 
In the /ec_cone/ namelist section, specify (example for ncone=4):
 zst= 0.0d-2, 0.0d-2, 0.0d-2, 0.0d-2 ! [m] ! Z-coordinates for launching rays
 rst= 30.d-2, 30.d-2, 30.d-2, 30.d-2 ! [m] ! R-coordinates for launching rays
 phist= 0.d0,  0.d0,   0.d0,  0.d0
!     betast[degree] polar angle measured at source from xy-plane
 betast=-28.d0, -24.d0, 24.d0, 28.d0  
! This is very important! betast will determine initial Npar.

(Other variables in /ec_cone/ can be specified, see genray.in)

In the /ox/ namelist section, specify :
i_ox=2
!  i_ox=2 launch the ray using EC cone vertex coordinates calculations
!         and using OX transmission procedure.

eps_xe=5.e-2 
!eps_xe   The parameter which sets the vicinity
!         of the O-mode cutoff surface.
!         If xe > (1-eps_xe) then this subroutine will 
!         make the ray jump in small radius direction
!         and find the X mode.
!         eps_xe=1.d-2 is set as default in dinit.f

This parameter is very important. If it's too small, 
the O-mode would bounce back from vicinity of omega=omega_pe layer
before the code detects that it should be converted to X-mode.
If eps_xe is too large, the O-mode will be forced to convert
to X-mode (jump over cut-off) too soon, which is not very physical.
The problem in selecting the value of eps_xe is that the point
where O-mode bounces back depends on Npar.

Other values to consider:
In the original Genray code, the program was always shifting the launching
point inwards until rho is below 1 [see plasmray_xyz() and edgcor_xyz()]. 
In the present version, this condition is disabled,
so the code will attempt to find a wave at the launching point.
However, the density at large rho can be too low, causing problems during
search of initial Nperp, so it is recommended 
to add a small background density.

ox_step_dir    defines the type of stepping in O-X conversion case,
               when looking for X-mode across evanescent layer.
               'gradne' - step along grad(ne) direction, or
               'vgroup' - along Vgroup velocity direction
                        taken just before O-X jump is initiated.
               The original (only) option was effectively 'gradne'.
               The stepping is done in subroutine find_rho_X_xyz()
               until the X mode is found. 
               Sometimes such stepping along grad(ne) direction
               results in an angled (rather than smooth) ray jump
               across the evanescent layer. The second option, 
               'vgroup' usually gives a smooth transition,
               however, as the ray tends to slow down 
               in normal-to-flux-surface direction, 
               while the tangential group velocity may remain 
               almost unchanged, the ray may "slide"
               along the surface, and the O-X transition can be missed.


=====================================================================
i_ox=1 option:
Optimal angle launch for O-mode, to be converted to X-mode.
The optimal angle is found by the following procedure:
1. The O-mode root is searched in the vicinity of Xe=1 layer in plasma
   (omega_pe^2/omega^2  ~ 1).
   The value of Npar is selected in such a way that the transmission
   coefficient to X-mode is 1 (all power is transmitted).
   The value of Nperp for the O-mode is found from the cold plasma 
   dispersion relation.
2. The O-mode with those Npar and Nperp is traced back to the 
   plasma edge, to the surface where antenna is positioned. This tracing
   is done with the negative time step in ray-tracing equations.
   Since the Xe=1 layer is stretched vertically in Z-direction 
   (in poloidal theta angles), the point where a ray arrives 
   at the plasma edge depends on initial theta at Xe~1 layer.
   This fact allows launching several rays from Xe~1 layer 
   with different initial theta, and then selecting the ray that 
   comes close to the antenna position.
3. For the selected ray, the values of betast,alfast,phist are saved 
   into ECcone_optimal.dat file, together with rst and zst 
   (they should be close to values of rst and zst of antenna position
   specified in genray.in during i_ox=1 run).
4. If the run with i_ox=1 was successful (ECcone_optimal.dat is created)
   make another run with i_ox=2 using the values taken from 
   the ECcone_optimal.dat file.  

   
Technical details.

In genray.in, in /wave/ namelist section, specify 
 jwave=+1 ! EC wave
 ioxm=+1  ! The code will be looking for Nperp of O-mode at launching point
 ibw=0    ! Not a direct EBW launch (but rather through O-X-EBW)
 istart=1 ! Use /ec_cone/ namelist section for starting conditions
 
In the /ec_cone/ namelist section, specify the antenna position 
(example for ncone=1):
 zst=-0.06d0  ![m]! Should be ncone entries 
 rst= 0.30d0  ![m]! Should be ncone entries 
 
The values of phist,betast,alfast angles are not important for i_ox=1 run.
They will be determined/re-defined, 
and then saved into ECcone_optimal.dat file. 
For i_ox=1 run, just set them to 0:
 phist= 0.d0  ![deg]! Should be ncone entries 
 betast=0.d0 ! from xy-plane ! Equals  -(polar_angle-90.)
 alfast=0.180d+03 ![deg]! 180. means the N vector is pointing inward

In the /ox/ namelist section of genray.in, specify:
  i_ox=1
  theta_top(1)=+0.d0  ! [deg] should be ncone entries
  theta_bot(1)=-4.d0  ! [deg] should be ncone entries
  i_ox_poloidal_max=10 ! number of rays with theta in the range [theta_bot theta_top]
In the example above, the rays will be launched from vicinity 
of Xe~1 layer at initial poloidal angles in the range [-4; 0] degrees.
Totally 10 rays will be launched with positive Npar ,
and 10 rays with negative Npar. The rays are traced back to the 
surface that contains antenna. The ending point of a ray is designated
as (r_st_ox,z_st_ox).

Also specify:
  eps_antenna=1.d-2 ![m]! vertical (in Z) "extension" of antenna
! If the ending point (r_st_ox,z_st_ox)
! is close enough to the antenna position, the ray is selected as
! the "optimal" ray to be launched from antenna in the run with i_ox=2.
! More specifically, for the antenna positioned  
! at rst(icone),zst(icone)  (specified in genray.in),  
! the ray is selected if(abs(z_st_ox-zst(icone)) .le. eps_antenna*0.5)
The very first ray that satisfies this condition is selected.
If the value of eps_antenna is too small, it might happen that
none of rays come close to antenna, i.e. the condition
|z_st_ox-zst(icone)| < eps_antenna*0.5   is never satisfied.
But instead of increasing the value of eps_antenna
it is recommended to check the following print-out from subr. outpt_xyz
(for each ray):
           write(*,*)'r_st_ox is found:',r_st_ox
           write(*,*)'x_st_ox=',x_st_ox
           write(*,*)'y_st_ox=',y_st_ox
           write(*,*)'z_st_ox=',z_st_ox
In particular, the value of z_st_ox should be checked,
for all rays, including positive Npar (i_n_optimal=1) 
and negative Npar (i_n_optimal=2). If the values of z_st_ox
are too far from the antenna position zst, the range of initial 
poloidal angles [theta_bot theta_top] should be adjusted, 
to "aim" rays closer to the antenna. 
If the antenna position zst is seen to be between values of 
z_st_ox of two rays, it is recommended to increase the number
of rays (i_ox_poloidal_max) or to increase eps_antenna. 

Also specify  
  eps_xe=20.d-2 
This is the parameter which defines where the O-mode is searched.
The value of 0.2 in example above means that the O-mode will
be searched at Xe=0.8 layer. The rays are then started from this layer
and traced back to the plasma edge. 
If eps_xe is too small (too close to Xe~1) the code may not be able
to find the O-mode because the root might be too close to the X-mode.
Generally, for larger "shooting" poloidal angles, the value of eps_xe
should be larger. Thus, if one or both of [theta_bot theta_top] 
angles is far from the midplane, the value of eps_xe 
should be large enough. 
(Note that the value of eps_xe is also used in i_ox=2 runs,
when O-mode is launched from plasma edge.
If eps_xe is too small, the O-mode will bounce back to the edge 
at Xe~1 layer, instead of being transformed into X-mode.)


Make a run with i_ox=1. 
Check that the file ECcone_optimal.dat is created. 
It should contain (example):
 i_n_optimal( 1)= 1
 zst( 1)=-.642643026361234D-01
 rst( 1)=0.300016562294231D+00
 phist( 1)=0.000000000000000D+00
 betast( 1)=0.526188957229075D+02
 alfast( 1)=0.180000000000000D+03
Sometimes it may contain two sets of such data.
It means that the vertical extension of antenna is too large,
and the rays with both positive Npar and negative Npar 
could reach the antenna.

Check that rst and zst are close to the values in genray.in,
within the half-height of the antenna (eps_antenna/2).
The accuracy is determined mainly by eps_antenna, 
and by the time step, in less extent.

Use the values from ECcone_optimal.dat for the run with i_ox=2.
In genray.in, change i_ox to 2, 
substitute values of rst, zst, phist, betast, alfast
by values from ECcone_optimal.dat, and make a run.
The values in ECcone_optimal.dat correspond to the optimal angle
launch of the O-mode. The plot of delpwr should show a very small
(ideally zero) drop in ray's power at the conversion layer Xe=1.


c=======================================================================
c  output/plots
c  The plotting is done with Python program genray_plot.py
c  which makes plots of plasma profiles, rays' propagation, etc.
c  During Genray-C run, The data is saved into genray.nc file
c  which is used by genray_plot.py.
c 
c-----------------------------------------------------------------------
!-----------------------------------------------------------------------
! Optional plots of Dispersion Roots 
! (may take longer runs + large genray.nc files)
!-----------------------------------------------
! To calculate and save the plasma dispersion roots into genray.nc file,
! for further plotting with genray_plot.py.
! Both cold and hot plasma roots are calculated. 
! See subr. wrtnetcdf_plasma_prof, file netcdfr3d.f, lines ~ 538-660.
!
! i_save_disp=0 (default value: do not save)  or =1 (save)
!
!    For i_save_disp=1 option:
! ixscan_save_disp=1000 (example) 
!    Nperp is calculated over refined x-grid: xscan(ixscan_save_disp).
!
! inpar_save_disp=10 (example) 
!    Value of inpar_save_disp sets the number of Npar values 
!    for Nperp(xscan) plots.
!    One plot is made/saved for each value of Npar.
!
! inper_save_disp=100 (example)
!    Value of inper_save_disp sets the grid size for Nperp
!    in calculations of ddd(xscan,Npergrid,Npar)
!    (ddd= dispersion function). 
!    One set of ddd(xscan,Npergrid) is saved for each value of Npar.
!
!    The limits in (X,Y,Z) coordinates where dispersion roots are calc.:
!    The scan is performed at fixed values of Y and Z coordinates: 
! y_save_disp=0.d0 (default value)
! z_save_disp=0.d0 (default value)
!    The scan is done along the X coordinate:
! xmin_save_disp= 0.
! xmax_save_disp= 0.3d0 ! [m] (example)
!    Set xmax_save_disp to wall_rmax
!    or smaller X where plasma is present (and equilib. B is defined).
!    These values correspond to the limits for xscan grid 
!    [xmin_save_disp : xmax_save_disp]  (but not exceeding equilib.grid)
!
!    The limits for Npar values and Nperp values:
! Npar_mn_save_disp=0.d0 ! Smallest Npar
! Npar_mx_save_disp=1.   ! Largest  Npar 
! Nper_mn_save_disp=1.d-3! Smallest Nper
! Nper_mx_save_disp=100. ! Largest  Nper for ddd(x,Nper,Npar) data
!    With the example above, it takes ~3min to scan X and get the data;
!    The progress is printed out for each Npar.
!    It is recommended to save such data only once for a given device,
!    as it may take too much cpu time and memory. 
!
!----------------------------------------------------------------------



  rho_larm_max  == Upper limit for Larmor radius [cm] 
  
  Set the value in &dispers section of genray.in.
  It is used for absorption calculation 
  (for iabsorp=3, i.e. when using subr. absorpfd_xyz, for now).
  This is done to address the inflation of argument of bessel function
  when ray goes over B~0 point (in FRC).
  Recommended: In FRC run (when magn. field B can go through zero)
  set it to the distance between null point r0 and separatrix rs. 
  Default value is rho_larm_max=10.d10, which effectively means 
  no upper limit.
  Physically, even at B=0 the Larmor radius cannot be zero because 
  a particle travels away from the localized B=0 layer
  and spends most of time in regions where B>0.
  An accurate value of rho_larm_max can be found from particle tracing
  (using some other codes), although the trajectory may not look like
  a circular orbit, especially for fast particles.
  If the value of rho_larm_max is set to a very small value, the damping
  of waves on fast ions (finite-Larmor radius effects) will be reduced 
  because the value of Kperp*rho_larm will be too small.
  Setting rho_larm_max to the recommended distance (rs-r0) improves 
  the stability of runs.
  
!------------------------------------------------------------------------